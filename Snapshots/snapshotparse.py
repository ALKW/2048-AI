import sys
from NNetwork import life
from NNetwork import neural_network as network

# Single pass parser that builds a life object from a snapshot (.snp) file
# .snp files are generated by the snapshotgen.py file
class Cons:
    OP = 1
    WEIGHT = 0
    DESC = 1
    NUMBER = 2
    CONNECTIONS = 3

class Parser:
    def __init__(self, filename):
        if ".snp" not in filename:
            print("Invalid file type, quitting...")
            sys.exit()

        self.file = open(filename, "r")
        self.curr_line = ""
        self.net_index = 0
        self.input = []
        self.internal = []
        self.output = []
        self.num_inputs = 0
        self.num_internal = 0
        self.num_outputs = 0
        self.ops = {"GG": self.build_gtoi_key, 
                    "GS": self.build_species_key, 
                    "NS": self.build_network,
                    "Network" : self.get_net_num,
                    "Input": self.build_input,
                    "Internal": self.build_internal,
                    "Ouptput": self.build_output}
    def clear_lists(self):
        self.input = []
        self.internal = []
        self.output = []

    def build_world(self):
        self.curr_line = self.file.readline()
        while self.curr_line:
            # Ignore comments
            if "#" in self.curr_line:
                self.curr_line = self.file.readline()
                continue

            # "$" Indicates a new category
            if "$" in self.curr_line:
                choice = self.curr_line.split(" ")
                self.ops[choice[Cons.OP]]()

            self.curr_line = self.file.readline()
        return self.world


    def build_gtoi_key(self):
        KEY = 0
        VALUE = 1

        self.curr_line = self.file.readline()
        while self.curr_line:
            # If we see a "$" then we know we are in another section
            if "$" in self.curr_line:
                return
            elif "#" in self.curr_line:
                self.curr_line = self.file.readline()
                continue
            else:
                key_val = self.curr_line.split(":")
                network.Network.gene_to_innovation_key[key_val[KEY]] =  key_val[VALUE]
                network.Network.innovation_to_gene_key[key_val[VALUE]] =  key_val[KEY]
            
            # Read next line in    
            self.curr_line = self.file.readline()


    def build_species_key(self):
        KEY = 0
        VALUE = 1

        self.curr_line = self.file.readline()
        while self.curr_line:
            # If we see a "$" then we know we are in another section
            if "$" in self.curr_line:
                return
            # Skip comments
            elif "#" in self.curr_line:
                self.curr_line = self.file.readline()
                continue
            else:
                key_val = self.curr_line.split(":")
                life.Life.species[key_val[KEY]] = key_val[VALUE]
            
            # Read next line in    
            self.curr_line = self.file.readline()

    def build_network(self):
        # Initialize the life object with the a number of empty networks equal to the number of networks in the file
        self.curr_line = self.file.readline()
        world_size = int(self.curr_line.split(":")[1])
        self.world = network.create_init_population(world_size,                     
                    [
                    0,0,0,0,
                    0,0,0,0,
                    0,0,0,0,
                    0,0,0,0,
                    0,0,0,0,
                    0,0,0,0
                    ], 
                    ["up", "down", "left", "right"])

        # Update node information in the network
        self.curr_line = self.file.readline()
        while self.curr_line:
            # Skip commented lines
            if "#" in self.curr_line:
                self.curr_line = self.file.readline()
                continue

            # Go to the operator's section
            if "$" in self.curr_line:
                choice = self.curr_line.split(" ")
                self.ops[choice[Cons.OP]]()
            
            # Read next line in    
            self.curr_line = self.file.readline()
        
        pass

    # Get the network number 
    def get_net_num(self, params):
        self.net_index = params[2]

    # Build/update an input node in a network
    def build_input(self):
        self.num_inputs = self.curr_line.split(" ")[2]
        self.curr_line = self.file.readline()
        while self.curr_line:
            if "$" in self.curr_line:
                return

            # Get the node and the parameters to update
            params = self.curr_line.split(":")
            node = self.world.population[self.net_index].input[params[Cons.NUMBER] * -1]
            
            # Update the node's parameters
            node.weight = int(params[Cons.WEIGHT])
            node.number = int(params[Cons.NUMBER])

            # Add the node to the list of inputs so we can go back and assign connections
            self.input.append(params)

            # Read the next line
            self.curr_line = self.file.readline()
    
    # Build/update an internal node in a network
    def build_internal(self):
        self.num_internal = self.curr_line.split(" ")[2]
        self.curr_line = self.file.readline()
        while self.curr_line:
            if "$" in self.curr_line:
                return

            # Make an internal node and append it to the networks list of internal nodes
            params = self.curr_line.split(":")
            n = network.node.Node(weight=params[Cons.WEIGHT], desc=params[Cons.DESC], num=params[Cons.NUMBER])
            self.world.population[self.net_index].internal.append(n)

            # Read the next line in
            self.curr_line = self.file.readline()

    # Build/update an output node in a network
    def build_output(self):
        self.num_outputs = self.curr_line.split(" ")[2]
        self.curr_line = self.file.readline()
        while self.curr_line:
            if "$" in self.curr_line:
                break

            # Get the node and the parameters to update
            params = self.curr_line.split(":")
            node = self.world.population[self.net_index].output[params[Cons.NUMBER]  + self.num_inputs + 1]

            # Update the node's parameters
            node.weight = int(params[Cons.WEIGHT])
            node.number = int(params[Cons.NUMBER])
            node.desc = params[Cons.DESC]

            # Read the next line
            self.curr_line = self.file.readline()

        # Build connections for input nodes
        self.build_input_connections()

        # Build connections for internal nodes
        self.build_internal_connections()

        # Build connections for output nodes
        self.build_output_connections()

        # Clear the lists for the next network
        self.clear_lists()

    def build_input_connections(self):
        # Append nodes to all input nodes connections list based on the snapshot data
        for node_params in self.input:
            # Get the node and the connections for that node
            connections = node_params[Cons.CONNECTIONS].split(",")
            node = self.world.population[self.net_index].inputs[node_params[Cons.NUMBER] * -1]

            # Add the node that corresponds to the number to the list of connections
            for con_num in connections:
                # For input nodes, a node in its connection list with a negative number indicates that it is an output node
                if con_num < 0:
                    output_index = node_params[Cons.NUMBER] + self.num_inputs + 1
                    node.connections.append(self.world.population[self.net_index].output[output_index])
                else:
                    internal_index = con_num
                    node.connections.append(self.world.population[self.net_index].internal[internal_index])

    def build_internal_connections(self):
        # Append nodes to all input nodes connections list based on the snapshot data
        for node_params in self.internal:
            # Get the node and the connections for that node
            connections = node_params[Cons.CONNECTIONS].split(",")
            node = self.world.population[self.net_index].inputs[node_params[Cons.NUMBER]]

            # Add the node that corresponds to the number to the list of connections
            for con_num in connections:
                # For internal nodes, a node in its connection list with a number less than the number of input nodes indicates that it is an output node
                if con_num < self.num_inputs * -1:
                    output_index = node_params[Cons.NUMBER] + self.num_inputs + 1
                    node.connections.append(self.world.population[self.net_index].output[output_index])
                else:
                    input_index = node_params[Cons.NUMBER] * -1
                    node.connections.append(self.world.population[self.net_index].input[input_index])

    def build_output_connections(self):
        # Append nodes to all input nodes connections list based on the snapshot data
        for node_params in self.output:
            # Get the node and the connections for that node
            connections = node_params[Cons.CONNECTIONS].split(",")
            node = self.world.population[self.net_index].inputs[node_params[Cons.NUMBER] + self.num_inputs + 1]

            # Add the node that corresponds to the number to the list of connections
            for con_num in connections:
                # For output nodes, a node in its connection list with a negative number indicates that it is an input node
                if con_num < 0:
                    input_index = node_params[Cons.NUMBER] * -1
                    node.connections.append(self.world.population[self.net_index].input[input_index])
                else:
                    internal_index = con_num
                    node.connections.append(self.world.population[self.net_index].internal[internal_index])